================================================================================
                    COURS ANGULAR COMPLET POUR DÉBUTANTS
                    + EXPLICATION DÉTAILLÉE DU PROJET MÉTÉO
                                PARTIE 2
================================================================================

3.3 MODÈLES DE DONNÉES
========================

a) weather.model.ts
```typescript
// Interface pour une ville
export interface City {
  name: string;        // Nom de la ville
  lat: number;         // Latitude
  lon: number;         // Longitude
  country: string;     // Pays
  state?: string;      // État/Région (optionnel)
}

// Interface pour la météo actuelle
export interface CurrentWeather {
  coord: {             // Coordonnées géographiques
    lat: number;
    lon: number;
  };
  weather: Array<{     // Conditions météo
    id: number;
    main: string;
    description: string;
    icon: string;
  }>;
  main: {              // Données principales
    temp: number;      // Température en °C
    feels_like: number; // Température ressentie
    pressure: number;  // Pression en hPa
    humidity: number;  // Humidité en %
  };
  wind: {              // Données du vent
    speed: number;     // Vitesse en km/h
    deg: number;       // Direction en degrés
  };
  visibility: number;  // Visibilité en mètres
  name: string;        // Nom de la ville
  sys: {               // Informations système
    country: string;   // Code pays
    sunrise: number;   // Lever du soleil (timestamp)
    sunset: number;    // Coucher du soleil (timestamp)
  };
}
```

POURQUOI CES INTERFACES ?
- TypeScript : sécurité des types
- Réutilisabilité : mêmes structures partout
- Maintenance : modification centralisée
- Documentation : code auto-documenté

3.4 SERVICES
=============

a) weather.service.ts
```typescript
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, catchError, map, throwError } from 'rxjs';

@Injectable({
  providedIn: 'root'  // Service disponible globalement
})
export class WeatherService {
  private readonly apiKey = environment.openWeatherMapApiKey;  // Clé API
  private readonly baseUrl = environment.openWeatherMapBaseUrl; // URL de base

  constructor(private http: HttpClient) {}  // Injection du service HTTP

  /**
   * Récupère la météo actuelle d'une ville
   */
  getCurrentWeather(city: string): Observable<CurrentWeather> {
    const params = new HttpParams()           // Paramètres de requête
      .set('q', city)                         // Nom de la ville
      .set('appid', this.apiKey)              // Clé API
      .set('units', 'metric')                 // Unités métriques (°C, km/h)
      .set('lang', 'fr');                     // Langue française

    return this.http.get<CurrentWeather>(`${this.baseUrl}/weather`, { params })
      .pipe(
        catchError(this.handleError)          // Gestion des erreurs
      );
  }

  /**
   * Récupère les prévisions 24h
   */
  getForecast24h(lat: number, lon: number): Observable<ForecastResponse> {
    const params = new HttpParams()
      .set('lat', lat.toString())             // Latitude
      .set('lon', lon.toString())             // Longitude
      .set('appid', this.apiKey)
      .set('units', 'metric')
      .set('lang', 'fr')
      .set('cnt', '8');                       // 8 prévisions = 24h

    return this.http.get<ForecastResponse>(`${this.baseUrl}/forecast`, { params })
      .pipe(
        catchError(this.handleError)
      );
  }

  /**
   * Récupère les prévisions 7 jours (utilise l'API 5-day forecast gratuite)
   */
  getForecast7days(lat: number, lon: number): Observable<ForecastResponse> {
    const params = new HttpParams()
      .set('lat', lat.toString())             // Latitude
      .set('lon', lon.toString())             // Longitude
      .set('appid', this.apiKey)
      .set('units', 'metric')
      .set('lang', 'fr');
      // Pas de cnt pour récupérer toutes les prévisions 5 jours (40 points)

    return this.http.get<ForecastResponse>(`${this.baseUrl}/forecast`, { params })
      .pipe(
        catchError(this.handleError)
      );
  }

  /**
   * Gestion des erreurs HTTP
   */
  private handleError(error: any): Observable<never> {
    let errorMessage = 'Une erreur est survenue';
    
    if (error.status === 401) {
      errorMessage = 'Clé API invalide. Vérifiez votre configuration.';
    } else if (error.status === 404) {
      errorMessage = 'Ville non trouvée. Vérifiez l\'orthographe.';
    } else if (error.status === 429) {
      errorMessage = 'Limite de requêtes API atteinte. Réessayez plus tard.';
    } else if (error.status === 0) {
      errorMessage = 'Pas de connexion internet. Vérifiez votre connexion.';
    }

    console.error('Erreur API:', error);
    return throwError(() => new Error(errorMessage));
  }
}
```

EXPLICATION DES CONCEPTS :
- @Injectable : Décorateur pour créer un service
- HttpClient : Service Angular pour les requêtes HTTP
- Observable : Type RxJS pour les données asynchrones
- HttpParams : Construction sécurisée des paramètres d'URL
- catchError : Opérateur RxJS pour gérer les erreurs

b) error.service.ts
```typescript
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

export interface AppError {
  id: string;
  title?: string;
  message: string;
  type: 'error' | 'warning' | 'info';
  timestamp: number;
  details?: string;
  action?: string;
  actionCallback?: () => void;
}

@Injectable({
  providedIn: 'root'
})
export class ErrorService {
  private errorsSubject = new BehaviorSubject<AppError[]>([]);
  private globalErrorSubject = new BehaviorSubject<AppError | null>(null);

  public errors$ = this.errorsSubject.asObservable();
  public global$ = this.globalErrorSubject.asObservable();

  /**
   * Ajoute une erreur à la liste
   */
  addError(message: string, type: 'error' | 'warning' | 'info' = 'error', 
           details?: string, action?: string, actionCallback?: () => void): string {
    const error: AppError = {
      id: this.generateId(),
      message,
      type,
      timestamp: Date.now(),
      details,
      action,
      actionCallback
    };

    const currentErrors = this.errorsSubject.value;
    const updatedErrors = [...currentErrors, error];
    
    // Limiter à 10 erreurs maximum
    if (updatedErrors.length > 10) {
      updatedErrors.shift();
    }

    this.errorsSubject.next(updatedErrors);

    // Si c'est une erreur critique, l'afficher globalement
    if (type === 'error') {
      this.setGlobalError(error);
    }

    return error.id;
  }
}
```

POURQUOI UN SERVICE D'ERREURS ?
- Gestion centralisée des erreurs
- Affichage cohérent dans toute l'app
- Possibilité d'actions sur les erreurs
- Historique des erreurs

3.5 COMPOSANTS MÉTÉO
======================

a) weather-card.component.ts
```typescript
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { CurrentWeather } from '../../models/weather.model';

@Component({
  selector: 'app-weather-card',
  templateUrl: './weather-card.html',
  styleUrl: './weather-card.scss'
})
export class WeatherCardComponent {
  @Input() weather!: CurrentWeather;        // Données météo reçues du parent
  @Input() isFavorite: boolean = false;     // État favori
  @Output() favoriteToggle = new EventEmitter<CurrentWeather>(); // Événement vers le parent

  /**
   * Bascule l'état favori
   */
  toggleFavorite(): void {
    this.favoriteToggle.emit(this.weather);  // Émet l'événement vers le parent
  }

  /**
   * Obtient l'icône météo appropriée
   */
  getWeatherIcon(iconCode: string): string {
    return `https://openweathermap.org/img/wn/${iconCode}@2x.png`;
  }

  /**
   * Obtient la classe CSS pour la température
   */
  getTemperatureClass(temp: number): string {
    if (temp < 0) return 'text-primary';      // Bleu pour le froid
    if (temp < 15) return 'text-info';        // Bleu clair pour le frais
    if (temp < 25) return 'text-success';     // Vert pour le doux
    if (temp < 35) return 'text-warning';     // Orange pour le chaud
    return 'text-danger';                      // Rouge pour le très chaud
  }
}
```

EXPLICATION DES DÉCORATEURS :
- @Input() : Propriété reçue du composant parent
- @Output() : Événement émis vers le composant parent
- EventEmitter : Type pour émettre des événements

b) weather-card.html
```html
<div class="weather-card">
  <div class="card h-100">
    <div class="card-header d-flex justify-content-between align-items-center">
      <h5 class="card-title mb-0">{{ weather.name }}</h5>
      
      <!-- Bouton favori -->
      <button class="btn btn-sm" 
              [class.btn-outline-danger]="!isFavorite"
              [class.btn-danger]="isFavorite"
              (click)="toggleFavorite()">
        <i class="bi" [class.bi-heart]="!isFavorite" [class.bi-heart-fill]="isFavorite"></i>
      </button>
    </div>
    
    <div class="card-body text-center">
      <!-- Icône météo -->
      <div class="weather-icon mb-3">
        <img [src]="getWeatherIcon(weather.weather[0].icon)" 
             [alt]="weather.weather[0].description"
             class="weather-icon-img">
        <p class="weather-description">{{ weather.weather[0].description }}</p>
      </div>
      
      <!-- Température principale -->
      <div class="temperature mb-3">
        <span class="temp-value" [class]="getTemperatureClass(weather.main.temp)">
          {{ weather.main.temp | number:'1.0-0' }}°C
        </span>
        <div class="temp-feels-like">
          Ressenti: {{ weather.main.feels_like | number:'1.0-0' }}°C
        </div>
      </div>
      
      <!-- Détails météo -->
      <div class="weather-details">
        <div class="detail-item">
          <i class="bi bi-droplet"></i>
          <span>{{ weather.main.humidity }}%</span>
        </div>
        <div class="detail-item">
          <i class="bi bi-wind"></i>
          <span>{{ weather.wind.speed | number:'1.0-0' }} km/h</span>
        </div>
      </div>
    </div>
  </div>
</div>
```

EXPLICATION DES DIRECTIVES :
- *ngIf : Affichage conditionnel
- *ngFor : Boucle sur des éléments
- [class] : Classe CSS conditionnelle
- (click) : Gestionnaire d'événement
- {{ }} : Interpolation de données
- | number : Pipe de formatage

c) search-bar.component.ts
```typescript
import { Component, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core';
import { FormControl } from '@angular/forms';
import { Subject, takeUntil, debounceTime, distinctUntilChanged } from 'rxjs';

@Component({
  selector: 'app-search-bar',
  templateUrl: './search-bar.html',
  styleUrl: './search-bar.scss'
})
export class SearchBarComponent implements OnInit, OnDestroy {
  @Output() search = new EventEmitter<string>();  // Événement de recherche
  @Output() locationRequest = new EventEmitter<void>(); // Demande de géolocalisation

  searchControl = new FormControl('');  // Contrôle du formulaire
  isSearching = false;                  // État de recherche

  private destroy$ = new Subject<void>();

  ngOnInit(): void {
    this.setupSearch();  // Configuration de la recherche
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  /**
   * Configure la recherche avec debounce
   */
  private setupSearch(): void {
    this.searchControl.valueChanges.pipe(
      takeUntil(this.destroy$),           // Se désabonner à la destruction
      debounceTime(300),                  // Attendre 300ms après la saisie
      distinctUntilChanged()              // Ignorer si la valeur n'a pas changé
    ).subscribe(searchTerm => {
      if (searchTerm && searchTerm.length >= 2) {
        this.search.emit(searchTerm);     // Émettre l'événement de recherche
      }
    });
  }

  /**
   * Demande la géolocalisation
   */
  onLocationRequest(): void {
    this.locationRequest.emit();
  }
}
```

POURQUOI LE DEBOUNCE ?
- Évite trop de requêtes API
- Améliore les performances
- Meilleure expérience utilisateur
- Économie de bande passante

3.6 PAGES DE PRÉVISIONS
=========================

a) forecast24h.component.ts
```typescript
import { Component, OnInit, OnDestroy, ViewChild } from '@angular/core';
import { Subject, takeUntil, switchMap, catchError, of } from 'rxjs';

@Component({
  selector: 'app-forecast24h',
  templateUrl: './forecast24h.html',
  styleUrl: './forecast24h.scss'
})
export class Forecast24hComponent implements OnInit, OnDestroy {
  @ViewChild(ForecastChartComponent) chartComponent!: ForecastChartComponent;

  hourlyForecast: ForecastItem[] = [];  // Prévisions horaires
  city: City | null = null;             // Ville sélectionnée
  isLoading: boolean = false;            // État de chargement
  errorMessage: AppError | null = null;  // Message d'erreur
  
  private destroy$ = new Subject<void>(); // Pour nettoyer les souscriptions

  ngOnInit(): void {
    this.setupErrorHandling();           // Configuration de la gestion d'erreurs
    this.loadForecastFromRoute();        // Chargement des prévisions
  }

  ngOnDestroy(): void {
    this.destroy$.next();                // Émettre la valeur de destruction
    this.destroy$.complete();            // Compléter le Subject
  }

  /**
   * Charge les prévisions depuis les paramètres de route
   */
  private loadForecastFromRoute(): void {
    this.route.queryParams.pipe(         // Écouter les paramètres d'URL
      takeUntil(this.destroy$),          // Se désabonner à la destruction
      switchMap(params => {              // Transformer les paramètres en requête
        const lat = parseFloat(params['lat']);
        const lon = parseFloat(params['lon']);
        const cityName = params['city'];

        if (!lat || !lon) {
          throw new Error('Coordonnées manquantes');
        }

        this.city = {
          name: cityName || 'Position actuelle',
          lat,
          lon,
          country: params['country'] || ''
        };

        return this.weatherService.getForecast24h(lat, lon);
      }),
      catchError(error => {              // Gestion des erreurs
        this.errorService.handleApiError(error, 'Chargement prévisions 24h');
        return of(null);                 // Retourner null en cas d'erreur
      })
    ).subscribe(forecast => {            // S'abonner aux résultats
      if (forecast) {
        this.hourlyForecast = forecast.list;
        this.prepareChartData();         // Préparer les données du graphique
        this.clearError();
      }
    });
  }

  /**
   * Prépare les données pour le graphique
   */
  private prepareChartData(): void {
    if (!this.hourlyForecast.length) return;

    // Créer un objet ForecastResponse compatible avec le composant
    this.chartData = {
      list: this.hourlyForecast,
      city: {
        name: this.city?.name || '',
        country: this.city?.country || '',
        coord: {
          lat: this.city?.lat || 0,
          lon: this.city?.lon || 0
        }
      }
    };
  }
}
```

EXPLICATION DES CONCEPTS RXJS :
- Subject : Émetteur/récepteur de valeurs
- takeUntil : Se désabonne automatiquement
- switchMap : Annule les requêtes précédentes
- catchError : Gère les erreurs dans le flux
- subscribe : S'abonne aux résultats

================================================================================
FIN DE LA DEUXIÈME PARTIE
================================================================================
