================================================================================
                    COURS ANGULAR COMPLET POUR DÉBUTANTS
                    + EXPLICATION DÉTAILLÉE DU PROJET MÉTÉO
                                PARTIE 3 (FINALE)
================================================================================

3.7 COMPOSANT DE GRAPHIQUE
============================

a) forecast-chart.component.ts
```typescript
import { Component, Input, Output, EventEmitter, OnInit, OnChanges, SimpleChanges, ViewChild, ElementRef } from '@angular/core';

// Chart.js types
declare var Chart: any;

@Component({
  selector: 'app-forecast-chart',
  templateUrl: './forecast-chart.html',
  styleUrl: './forecast-chart.scss'
})
export class ForecastChartComponent implements OnInit, OnChanges {
  @Input() forecastData: ForecastResponse | null = null;  // Données reçues
  @Input() title: string = 'Prévisions météo';            // Titre du graphique
  @Input() chartType: 'line' | 'bar' = 'line';           // Type de graphique
  @Input() period: '24h' | '7days' = '24h';              // Période
  
  @ViewChild('chartCanvas', { static: true }) chartCanvas!: ElementRef;

  chart: any = null;                    // Instance Chart.js
  chartData: any = null;                // Données formatées pour Chart.js
  chartOptions: any = {};               // Options du graphique

  ngOnInit(): void {
    this.setupChartOptions();            // Configuration des options
    this.processData();                  // Traitement des données
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['forecastData'] && !changes['forecastData'].firstChange) {
      this.processData();                // Retraiter si les données changent
    }
  }

  ngOnDestroy(): void {
    if (this.chart) {
      this.chart.destroy();              // Nettoyer le graphique
    }
  }

  /**
   * Crée ou met à jour le graphique Chart.js
   */
  private createOrUpdateChart(): void {
    if (!this.chartCanvas?.nativeElement) return;

    // Détruire l'ancien graphique s'il existe
    if (this.chart) {
      this.chart.destroy();
    }

    // Créer le nouveau graphique
    this.chart = new Chart(this.chartCanvas.nativeElement, {
      type: this.chartType,
      data: this.chartData,
      options: this.chartOptions
    });
  }
}
```

POURQUOI CHART.JS NATIF ?
- Évite les conflits avec ng2-charts
- Meilleur contrôle sur l'instance
- Pas de boucles infinies
- Performance optimisée

b) forecast-chart.html
```html
<div class="forecast-chart-container">
  <!-- En-tête du graphique -->
  <div class="chart-header" *ngIf="showControls">
    <div class="chart-title">
      <h5>{{ title }}</h5>
    </div>
    
    <div class="chart-controls">
      <div class="btn-group btn-group-sm" role="group">
        <button 
          type="button" 
          class="btn" 
          [class.btn-primary]="chartType === 'line'"
          [class.btn-outline-primary]="chartType !== 'line'"
          (click)="onChartTypeChange('line')"
          title="Graphique en ligne">
          <i class="bi bi-graph-up"></i>
        </button>
        <button 
          type="button" 
          class="btn" 
          [class.btn-primary]="chartType === 'bar'"
          [class.btn-outline-primary]="chartType !== 'bar'"
          (click)="onChartTypeChange('bar')"
          title="Graphique en barres">
          <i class="bi bi-bar-chart"></i>
        </button>
      </div>
    </div>
  </div>

  <!-- Conteneur du graphique -->
  <div class="chart-wrapper" [style.height.px]="height">
    <canvas #chartCanvas></canvas>
    
    <!-- Message de chargement -->
    <div class="chart-loading" *ngIf="isLoading">
      <div class="loading-content">
        <i class="bi bi-arrow-clockwise bi-spin"></i>
        <p>Chargement du graphique...</p>
      </div>
    </div>
  </div>
</div>
```

3.8 PAGE DE LA CARTE
======================

a) map.component.ts
```typescript
import { Component, OnInit, OnDestroy, AfterViewInit, ViewChild, ElementRef } from '@angular/core';

// Leaflet types
declare var L: any;

@Component({
  selector: 'app-map',
  templateUrl: './map.html',
  styleUrl: './map.scss'
})
export class MapComponent implements OnInit, OnDestroy, AfterViewInit {
  @ViewChild('mapContainer') mapContainer!: ElementRef;

  // Map properties
  map: any = null;                    // Instance de la carte Leaflet
  currentMarker: any = null;          // Marqueur de la ville actuelle
  searchMarker: any = null;           // Marqueur de recherche
  weatherMarkers: any[] = [];         // Marqueurs météo
  weatherLayerGroup: any = null;      // Groupe de couches météo
  
  // Search properties
  searchControl = new FormControl(''); // Contrôle de recherche
  searchResults: City[] = [];          // Résultats de recherche
  isSearching: boolean = false;        // État de recherche
  
  // Weather data
  currentWeather: CurrentWeather | null = null; // Météo actuelle
  city: City | null = null;            // Ville sélectionnée

  ngOnInit(): void {
    this.setupErrorHandling();         // Configuration de la gestion d'erreurs
    this.setupSearch();                // Configuration de la recherche
    this.loadMapFromRoute();           // Chargement des paramètres de route
  }

  ngAfterViewInit(): void {
    this.initializeMap();              // Initialisation de la carte
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
    if (this.map) {
      this.map.remove();               // Nettoyer la carte
    }
  }

  /**
   * Initialise la carte Leaflet
   */
  private initializeMap(): void {
    // Configuration de la carte
    this.map = L.map(this.mapContainer.nativeElement, {
      center: [48.8566, 2.3522],      // Paris par défaut
      zoom: 10,
      zoomControl: true,
      attributionControl: true
    });

    // Ajout des tuiles OpenStreetMap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(this.map);

    // Groupe pour les marqueurs météo
    this.weatherLayerGroup = L.layerGroup().addTo(this.map);

    // Événements de la carte
    this.map.on('click', (e: any) => {
      this.onMapClick(e);              // Gérer le clic sur la carte
    });

    // Centrer sur la ville si spécifiée
    if (this.city) {
      this.centerMapOnCity(this.city.lat, this.city.lon);
      this.loadWeatherForCity(this.city.lat, this.city.lon);
    } else {
      // Essayer la géolocalisation
      this.getCurrentLocation();
    }
  }

  /**
   * Pointe sur une ville spécifique (comme Google Maps)
   */
  pointToCity(cityName: string): void {
    if (!cityName || cityName.trim().length < 2) {
      this.errorService.addError(
        'Nom de ville invalide',
        'warning',
        'Veuillez saisir un nom de ville valide (minimum 2 caractères)'
      );
      return;
    }

    this.isLoadingLocation = true;
    
    // Rechercher la ville
    this.weatherService.searchCities(cityName.trim()).pipe(
      takeUntil(this.destroy$),
      catchError(error => {
        this.errorService.handleApiError(error, 'Recherche ville');
        this.isLoadingLocation = false;
        return of([]);
      })
    ).subscribe(cities => {
      if (cities.length > 0) {
        // Prendre la première ville trouvée
        const city = cities[0];
        
        this.city = {
          name: city.name,
          lat: city.lat,
          lon: city.lon,
          country: city.country
        };
        
        // Centrer la carte sur la ville
        this.centerMapOnCity(city.lat, city.lon);
        
        // Charger la météo pour cette ville
        this.loadWeatherForCity(city.lat, city.lon);
        
        // Mettre à jour la barre de recherche
        this.searchControl.setValue(city.name);
        
        // Effacer les résultats de recherche
        this.searchResults = [];
        
        this.errorService.addError(
          'Ville trouvée !',
          'info',
          `${city.name}, ${city.country} a été localisée sur la carte`
        );
      } else {
        this.errorService.addError(
          'Ville non trouvée',
          'warning',
          `Aucune ville trouvée pour "${cityName}". Vérifiez l'orthographe.`
        );
      }
      
      this.isLoadingLocation = false;
    });
  }
}
```

POURQUOI LEAFLET ?
- Bibliothèque open source et gratuite
- Excellente performance
- Nombreuses couches disponibles
- Intégration facile avec Angular

3.9 STYLES ET CSS
===================

a) styles.scss (Styles globaux)
```scss
/* Import des bibliothèques CSS */
@import 'bootstrap/dist/css/bootstrap.min.css';    // Framework CSS Bootstrap
@import 'leaflet/dist/leaflet.css';                // Styles des cartes Leaflet
@import 'bootstrap-icons/font/bootstrap-icons.css'; // Icônes Bootstrap

/* Variables SCSS */
$primary-color: #007bff;
$success-color: #28a745;
$warning-color: #ffc107;
$danger-color: #dc3545;

/* Styles globaux */
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background-color: #f8f9fa;
}

.weather-app-container {
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

/* Mixins SCSS */
@mixin card-hover {
  transition: all 0.3s ease;
  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  }
}

/* Utilisation des mixins */
.card {
  @include card-hover;
  border: none;
  border-radius: 15px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
```

AVANTAGES DE SCSS :
- Variables réutilisables
- Mixins pour code répétitif
- Imbrication logique
- Calculs et opérations
- Import de fichiers

b) map.scss (Styles de la carte)
```scss
// Variables
$primary-color: #007bff;
$success-color: #28a745;
$warning-color: #ffc107;
$danger-color: #dc3545;
$info-color: #17a2b8;
$light-color: #f8f9fa;
$dark-color: #343a40;
$border-radius: 0.5rem;
$box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
$transition: all 0.3s ease;

// Mixins
@mixin card-hover {
  transition: $transition;
  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  }
}

// Styles principaux
.map-container {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: #f8f9fa;

  &.fullscreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 9999;
  }

  // Header Section
  .header-section {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding: 1rem 0;
    z-index: 1000;
    flex-shrink: 0;

    .page-title {
      color: $dark-color;
      font-weight: 700;
      margin: 0;
      font-size: 1.75rem;
      
      i {
        color: $primary-color;
        margin-right: 0.5rem;
      }
    }
  }

  // Map Controls
  .map-controls {
    position: absolute;
    top: 120px;
    right: 20px;
    z-index: 1000;
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      
      .btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.1);
        transition: $transition;
        
        &:hover {
          background: white;
          transform: scale(1.1);
          box-shadow: 0 0.25rem 0.5rem rgba(0, 0, 0, 0.15);
        }
        
        &.active {
          background: $primary-color;
          color: white;
          border-color: $primary-color;
        }
      }
    }
  }
}
```

3.10 FICHIERS DE CONFIGURATION
===============================

a) index.html
```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WeatherApp</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
  
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  
  <!-- Leaflet JavaScript -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>
</head>
<body>
  <app-root></app-root>
</body>
</html>
```

POURQUOI CES CDN ?
- Leaflet : Pour les cartes interactives
- Chart.js : Pour les graphiques de prévisions
- Intégrité : Sécurité des fichiers externes
- Performance : Chargement optimisé

================================================================================
4. CONCLUSION ET OBJECTIFS ATTEINTS
================================================================================

4.1 OBJECTIFS DU PROJET
=========================
L'objectif principal était de créer une application météo complète qui permet de :
- Afficher la météo actuelle d'une ville
- Consulter les prévisions sur 24h et 7 jours
- Visualiser les données sur des graphiques
- Naviguer sur une carte interactive
- Gérer une liste de villes favorites

4.2 COMMENT L'OBJECTIF EST ATTEINT
===================================

a) AFFICHAGE MÉTÉO PAR VILLE
   - Service WeatherService récupère les données via l'API OpenWeatherMap
   - Composant WeatherCard affiche les informations de manière claire
   - Gestion des erreurs et états de chargement

b) PRÉVISIONS 24H ET 7 JOURS
   - API 5-day forecast pour les données réelles
   - Simulation intelligente pour compléter à 7 jours
   - Graphiques Chart.js pour la visualisation
   - Composants dédiés pour chaque type de prévision

c) CARTE INTERACTIVE
   - Bibliothèque Leaflet pour l'affichage des cartes
   - Intégration des couches météo OpenWeatherMap
   - Géolocalisation et recherche de villes
   - Marqueurs et popups informatifs

d) NAVIGATION ET UX
   - Routing Angular pour la navigation entre pages
   - Interface responsive avec Bootstrap
   - Menu adaptatif mobile/desktop
   - Gestion des états et transitions

4.3 ARCHITECTURE ET MAINTENANCE
================================
L'application suit les bonnes pratiques Angular :

- Séparation des responsabilités (composants, services, modèles)
- Injection de dépendances pour la réutilisabilité
- Gestion des erreurs centralisée
- Code modulaire et maintenable
- Styles organisés et réutilisables

4.4 APPRENTISSAGE ANGULAR
==========================
Ce projet vous a permis de découvrir :

- Structure d'un composant Angular
- Communication entre composants
- Gestion des services et de l'état
- Routing et navigation
- Intégration d'APIs externes
- Gestion des erreurs
- Styles et responsive design
- Intégration de bibliothèques tierces

4.5 PROCHAINES ÉTAPES
=======================
Pour continuer votre apprentissage Angular :

1. Ajouter de nouvelles fonctionnalités (notifications, historique)
2. Implémenter l'authentification utilisateur
3. Ajouter des tests unitaires
4. Optimiser les performances
5. Déployer l'application
6. Explorer d'autres concepts (guards, interceptors, etc.)

4.6 RÉSUMÉ TECHNIQUE
======================
Technologies utilisées dans ce projet :

- **Angular 20** : Framework principal
- **TypeScript** : Langage de programmation
- **Bootstrap 5** : Framework CSS
- **Leaflet** : Bibliothèque de cartes
- **Chart.js** : Bibliothèque de graphiques
- **RxJS** : Gestion des flux asynchrones
- **SCSS** : Préprocesseur CSS
- **OpenWeatherMap API** : Données météo

4.7 BONNES PRATIQUES IMPLÉMENTÉES
==================================
- **Architecture modulaire** : Composants réutilisables
- **Gestion d'état** : Services centralisés
- **Gestion d'erreurs** : Service dédié avec messages utilisateur
- **Responsive design** : Adaptation mobile/desktop
- **Performance** : Lazy loading et optimisations
- **Accessibilité** : Attributs ARIA et navigation clavier
- **Sécurité** : Validation des entrées et gestion des erreurs

================================================================================
CONCLUSION FINALE
================================================================================

Ce projet météo vous a donné une base solide en Angular. Vous avez appris à :
- Structurer une application Angular
- Créer des composants réutilisables
- Gérer les services et la logique métier
- Intégrer des APIs externes
- Créer une interface utilisateur moderne
- Gérer la navigation et les états
- Intégrer des bibliothèques tierces
- Optimiser les performances
- Gérer les erreurs et les états de chargement

L'application est maintenant fonctionnelle et vous pouvez la personnaliser selon vos besoins. Continuez à explorer Angular et n'hésitez pas à expérimenter avec de nouvelles fonctionnalités !

4.8 RESSOURCES POUR CONTINUER
==============================
- **Documentation officielle Angular** : https://angular.io/docs
- **Angular University** : https://angular-university.io
- **RxJS Documentation** : https://rxjs.dev
- **Bootstrap Documentation** : https://getbootstrap.com/docs
- **Leaflet Documentation** : https://leafletjs.com/reference.html
- **Chart.js Documentation** : https://www.chartjs.org/docs

4.9 PROJETS D'ENTRAÎNEMENT SUGGÉRÉS
=====================================
1. **Application de gestion de tâches** : CRUD complet avec localStorage
2. **Blog personnel** : Système d'articles avec markdown
3. **Application de chat** : Communication en temps réel avec WebSockets
4. **Dashboard admin** : Tableaux de bord avec graphiques et statistiques
5. **Application e-commerce** : Catalogue, panier et commandes

Bon apprentissage ! 🚀🌤️

================================================================================
FIN DU COURS COMPLET
================================================================================
